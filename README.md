  # پروژه تونل‌سازی امن DNS با رمزنگاری متقارن

این پروژه یک سیستم ارتباطی امن و مخفیانه را پیاده‌سازی می‌کند که در آن کلاینت (Agent) داده‌های یک فایل را به صورت رمزنگاری شده از طریق کوئری‌های DNS به سرور ارسال می‌کند. هدف اصلی، نمایش امکان دور زدن محدودیت‌های شبکه با استفاده از DNS Tunneling و در عین حال، حفظ محرمانگی و یکپارچگی داده‌ها با استفاده از رمزنگاری متقارن (AES) است.

## ویژگی‌ها

* **رمزنگاری قدرتمند:** استفاده از الگوریتم `AES-256` در مد `GCM` برای تضمین محرمانگی و اصالت داده‌ها. 
* **انتقال فایل‌های بزرگ:** قابلیت تقسیم فایل‌ها به قطعات کوچک‌تر و ارسال آن‌ها در قالب چندین بسته `DNS`.
* **قابلیت اطمینان:** پیاده‌سازی مکانیزم تأیید دریافت `(ACK)` و ارسال مجدد بسته‌ها در صورت عدم دریافت پاسخ `(Timeout)`.
* **بازسازی مرتب داده‌ها:** استفاده از شماره ترتیب `(Sequence Number)` برای بازسازی صحیح فایل در سمت سرور، حتی اگر بسته‌ها خارج از نوبت دریافت شوند.
* **پروتکل سفارشی:** تعریف یک پروتکل ساده برای ارسال متادیتا (نام فایل) و تشخیص پایان انتقال `(EOF)`.
* **انعطاف‌پذیری:** امکان ارسال هر نوع فایل با دریافت نام آن از طریق خط فرمان.

## نحوه اجرا

برای اجرای این پروژه، مراحل زیر را دنبال کنید.

### ۱. پیش‌نیازها

* پایتون نسخه ۳.۷ یا بالاتر 
* کتابخانه‌های مورد نیاز که در فایل `requirements.txt` لیست شده‌اند.

### ۲. نصب

ابتدا وارد پوشه پروژه شوید.

```bash  
cd Secure_DNS_Tunnel/
```

یک محیط مجازی پایتون ایجاد و آن را فعال کنید.

```bash 
python3 -m venv venv
source venv/bin/activate
```

بسته‌های مورد نیاز را با استفاده از `pip` نصب کنید.

```bash 
pip install cryptography dnspython dnslib
```

### ۳. پیکربندی

تنظیمات اصلی پروژه در فایل config.py قرار دارد. در صورت نیاز می‌توانید مقادیر زیر را تغییر دهید:

* ‏`AES_KEY:` کلید رمزنگاری ۳۲ بایتی.
* ‏`TUNNEL_DOMAIN:` نام دامنه‌ای که برای تونل استفاده می‌شود.
* ‏`SERVER_IP:` آدرس IP سرور. برای تست محلی، `127.0.0.1` باقی بماند.
* ‏`DNS_PORT:` پورت سرور DNS. برای جلوگیری از خطای دسترسی، از یک پورت بالاتر از ۱۰۲۴ (مانند `5353`) استفاده شده است.

### ۴. اجرای سرور

در یک پنجره ترمینال، سرور را اجرا کنید. سرور شروع به گوش دادن به کوئری‌های `DNS` روی پورت مشخص شده می‌کند.

```bash
python3 server.py
```

خروجی مورد انتظار:

```bash
Starting DNS Server on 127.0.0.1:5353 for domain tunnel.croco.com...
Server initialized. Waiting for metadata...
```

### ۵. اجرای کلاینت (Agent)

در یک پنجره ترمینال دیگر، کلاینت را اجرا کرده و نام فایلی که قصد ارسال آن را دارید به عنوان آرگومان به آن بدهید.

```bash
python3 agent.py <path/to/your/file>
```

کلاینت فرآیند ارسال فایل را آغاز کرده و وضعیت ارسال هر بسته را نمایش می‌دهد. پس از اتمام، فایل ارسالی در پوشه `received_files` در سمت سرور ذخیره خواهد شد.

## جزئیات پیاده‌سازی

این بخش به توضیح نحوه پیاده‌سازی دو جزء اصلی پروژه می‌پردازد.

### نحوه پیاده‌سازی رمزنگاری

* **الگوریتم:** از `AES` (Advanced Encryption Standard) با کلید ۲۵۶ بیتی و در مد کاری `GCM` (Galois/Counter Mode) استفاده شده است.
* **مد GCM:** این مد علاوه بر محرمانگی (Encryption)، اصالت و یکپارچگی داده (Authentication & Integrity) را نیز فراهم می‌کند. این به آن معناست که سرور می‌تواند مطمئن باشد داده‌ها در حین انتقال دستکاری نشده‌اند.
* **کلید:** یک کلید متقارن ۳۲ بایتی که به صورت از پیش تعریف شده در فایل `config.py` بین کلاینت و سرور به اشتراک گذاشته شده است.
* ‏**Nonce:** برای هر بسته، یک Nonce (Number used once) ۱۲ بایتی تصادفی تولید می‌شود. این تضمین می‌کند که اگر دو قطعه داده یکسان رمزنگاری شوند، خروجی آن‌ها متفاوت خواهد بود که امنیت را افزایش می‌دهد.

### نحوه پیاده‌سازی DNS Tunneling

* **مفهوم اصلی:** داده‌ها پس از رمزنگاری، با فرمت `Base32` کدگذاری می‌شوند تا فقط شامل حروف و اعداد مجاز در نام دامنه باشند. سپس این رشته به قطعات کوچک‌تر (حداکثر ۶۳ کاراکتر) تقسیم شده و به عنوان زیردامنه‌های یک دامنه اصلی ارسال می‌گردد.
    * مثال کوئری: `[chunk-N]...[chunk-2].[chunk-1].tunnel.yourdomain.com`
* **پروتکل ارتباطی:** یک پروتکل ساده برای مدیریت فرآیند انتقال طراحی شده است که در آن، نوع هر بسته با بایت اول آن مشخص می‌شود:
    * ‏`0x00` **بسته متادیتا:** اولین بسته ارسالی که شامل نام فایل است. این به سرور امکان می‌دهد فایل را با نام و فرمت صحیح ذخیره کند.
    * ‏`0x01` **بسته داده:** حاوی شماره ترتیب (۴ بایت) و بخشی از داده‌های فایل است.
    * ‏`0x02` **بسته پایان فایل (EOF):** یک بسته خالی که به سرور اعلام می‌کند انتقال فایل به پایان رسیده است.
* **قابلیت اطمینان و بازسازی:**
    * **سمت کلاینت:** پس از ارسال هر بسته، کلاینت منتظر پاسخ DNS از سرور (به عنوان ACK) می‌ماند. اگر در مدت زمان مشخصی (Timeout) پاسخی دریافت نکند، بسته را مجدداً ارسال می‌کند.
    * **سمت سرور:** سرور بسته‌های دریافتی را بر اساس شماره ترتیب در یک بافر (دیکشنری) ذخیره می‌کند. این کار تضمین می‌کند که حتی اگر بسته‌ها به دلیل شرایط شبکه خارج از نوبت برسند، فایل نهایی به ترتیب صحیح بازسازی شود.
